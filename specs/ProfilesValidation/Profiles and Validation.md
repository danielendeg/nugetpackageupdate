FHIR is a platform standard. It follows the 80-20 rule; the basic fields of each resource represent what would cover 80% of what is needed and the use cases that fall in the other 20% would be expected to use extensions to add data to resources. Consequently, FHIR is very extensible. This also means that most practical use cases would need to constrain the data in some ways. Examples of such constraints may be to require the the Patient resource uses a certain specific identifier or one of just a few sets of identifiers. Customers will expect that our FHIR server has the ability to validate resources before they are created or updated (they may also want to validate if a certain resource can be deleted). 

The FHIR server needs the following capabilities:

1. Validate that a resource conforms to the base resource profile.
1. Validate that a resource conforms to a specific (custom) profile. 
1. Validate a resource before without upserting it ($validate).
1. Validate referential integrity, e.g. an Observation should not have an internal reference to a Patient that doesn't exist. 

Note that referential integraty and profile validation are really two different things, but they intersect and we will discuss them together in this document.

[[_TOC_]]

# Introduction to Profiling and Validation

Before diving into how specific design for the FHIR server, here is a small review of Profiling. To assist with the understanding, there is a sample `FHIRValidator` app in the [FHIRValidator/](FHIRValidator/) folder. You can run it with:

```
dotnet run /FileName <myresource.json> /Profile <canonical profile uri>
```

Generally profiling works by constraining an existing profile. In the case of a patient, one could restrict the cardinality or datatype for certain elements. There is no way to add fields that don't exist, but we can specify what can go into extensions, etc. As an example, suppose we wanted to create a profile for a Patient that could **not** have any Extensions, it could look like this:

```json
{
    "resourceType": "StructureDefinition",
    "id": "PatientWithNoExtensions",
    "url": "http://microsoft.com/fhir/StructureDefinition/PatientWithNoExtensions",
    "name": "PatientWithNoExtensions",
    "status": "draft",
    "date": "2017-04-19T07:44:43+10:00",
    "publisher": "Microsoft Healthcare NExT",
    "description": "Example Patient with no extensions",
    "fhirVersion": "3.0.1",
    "kind": "resource",
    "abstract":false,
    "type":"Patient",
    "baseDefinition":"http://hl7.org/fhir/StructureDefinition/Patient",
    "derivation":"constraint",
    "differential":{
        "element": [
            {
                "id":"Patient.extension",
                "path":"Patient.extension",
                "max": "0"
            }
        ]
    }
}
```

Note that the "snapshot" view of the basic resource has been excluded here, we are just adding a differential view. In this differential view, we are restricting the `extension` field to have max cardinality of zero.

If we consider a simple patient:

```json
{
    "resourceType": "Patient",
    "active": true,
    "name": [
        {
            "use": "official",
            "family": "Kirk",
            "given": [
                "James",
                "Tiberious"
            ]
        },
        {
            "use": "usual",
            "given": [
                "Jim"
            ]
        }
    ],
    "gender": "male",
    "birthDate": "1960-12-25"
}
```

we can use the `FHIRValidator` tool to validate against this profile:

```
dotnet run /FileName .\samples\simple-patient.json /Profile http://microsoft.com/fhir/StructureDefinition/PatientWithNoExtensions

```

we will get:

```
Overall result: SUCCESS
```

If on the other hand we consider a more complcated patient with multiple extensions:

```json
{
  "resourceType": "Patient",
  "id": "9f0817e0-51af-4c3f-8255-c4a9c73407f8",
  "meta": {
    "versionId": "1",
    "lastUpdated": "2019-01-30T03:34:14.9705186+00:00"
  },
  "text": {
    "status": "generated",
    "div": "<div xmlns=\"http://www.w3.org/1999/xhtml\">Generated by <a href=\"https://github.com/synthetichealth/synthea\">Synthea</a>.Version identifier: v2.2.0-56-g113d8a2d\n .   Person seed: 3716557023752549642  Population seed: 1546890380968</div>"
  },
  "extension": [
    {
      "extension": [
        {
          "url": "ombCategory",
          "valueCoding": {
            "system": "urn:oid:2.16.840.1.113883.6.238",
            "code": "2106-3",
            "display": "White"
          }
        },
        {
          "url": "text",
          "valueString": "White"
        }
      ],
      "url": "http://hl7.org/fhir/us/core/StructureDefinition/us-core-race"
    },
    {
      "extension": [
        {
          "url": "ombCategory",
          "valueCoding": {
            "system": "urn:oid:2.16.840.1.113883.6.238",
            "code": "2186-5",
            "display": "Not Hispanic or Latino"
          }
        },
        {
          "url": "text",
          "valueString": "Not Hispanic or Latino"
        }
      ],
      "url": "http://hl7.org/fhir/us/core/StructureDefinition/us-core-ethnicity"
    },
    {
      "url": "http://hl7.org/fhir/StructureDefinition/patient-mothersMaidenName",
      "valueString": "Kyung736 King743"
    },
    {
      "url": "http://hl7.org/fhir/us/core/StructureDefinition/us-core-birthsex",
      "valueCode": "M"
    },
    {
      "url": "http://hl7.org/fhir/StructureDefinition/birthPlace",
      "valueAddress": {
        "city": "Springfield",
        "state": "Massachusetts",
        "country": "US"
      }
    }
  ],
  "identifier": [
    {
      "system": "https://github.com/synthetichealth/synthea",
      "value": "97d5ce67-dde6-4ea8-b14f-5673fbe42698"
    },
    {
      "type": {
        "coding": [
          {
            "system": "http://hl7.org/fhir/v2/0203",
            "code": "MR",
            "display": "Medical Record Number"
          }
        ],
        "text": "Medical Record Number"
      },
      "system": "http://hospital.smarthealthit.org",
      "value": "97d5ce67-dde6-4ea8-b14f-5673fbe42698"
    },
    {
      "type": {
        "coding": [
          {
            "system": "http://hl7.org/fhir/identifier-type",
            "code": "SB",
            "display": "Social Security Number"
          }
        ],
        "text": "Social Security Number"
      },
      "system": "http://hl7.org/fhir/sid/us-ssn",
      "value": "999-46-6663"
    },
    {
      "type": {
        "coding": [
          {
            "system": "http://hl7.org/fhir/v2/0203",
            "code": "DL",
            "display": "Driver's License"
          }
        ],
        "text": "Driver's License"
      },
      "system": "urn:oid:2.16.840.1.113883.4.3.25",
      "value": "S99918002"
    },
    {
      "type": {
        "coding": [
          {
            "system": "http://hl7.org/fhir/v2/0203",
            "code": "PPN",
            "display": "Passport Number"
          }
        ],
        "text": "Passport Number"
      },
      "system": "http://standardhealthrecord.org/fhir/StructureDefinition/passportNumber",
      "value": "X58081047X"
    }
  ],
  "name": [
    {
      "use": "official",
      "family": "Gutkowski940",
      "given": [
        "Darwin703"
      ],
      "prefix": [
        "Mr."
      ]
    }
  ],
  "telecom": [
    {
      "system": "phone",
      "value": "555-360-6622",
      "use": "home"
    }
  ],
  "gender": "male",
  "birthDate": "1977-12-02",
  "address": [
    {
      "extension": [
        {
          "extension": [
            {
              "url": "latitude",
              "valueDecimal": 42.601979
            },
            {
              "url": "longitude",
              "valueDecimal": -71.815876
            }
          ],
          "url": "http://hl7.org/fhir/StructureDefinition/geolocation"
        }
      ],
      "line": [
        "954 Klocko Grove Apt 41"
      ],
      "city": "Fitchburg",
      "state": "Massachusetts",
      "postalCode": "01420",
      "country": "US"
    }
  ],
  "maritalStatus": {
    "coding": [
      {
        "system": "http://hl7.org/fhir/v3/MaritalStatus",
        "code": "M",
        "display": "M"
      }
    ],
    "text": "M"
  },
  "multipleBirthBoolean": false,
  "communication": [
    {
      "language": {
        "coding": [
          {
            "system": "urn:ietf:bcp:47",
            "code": "en-US",
            "display": "English"
          }
        ],
        "text": "English"
      }
    }
  ]
}
```

The result would be:

```
Overall result: FAILURE (1 errors and 0 warnings)

[ERROR] Instance count for 'Patient.extension' is 5, which is not within the specified cardinality of 0..0 (at Patient)
```

In this case, we are providing the profile we would like to validate against directly to the validator, but it can also be added to the resource:

```json
{
  "resourceType": "Patient",
  "id": "9f0817e0-51af-4c3f-8255-c4a9c73407f8",
  "meta": {
    "versionId": "1",
    "lastUpdated": "2019-01-30T03:34:14.9705186+00:00",
    "profile": [
        "http://microsoft.com/fhir/StructureDefinition/PatientWithNoExtensions" 
    ]
  },

  // Rest of resource
}
```

As is seen the `profile` metadata field is an array of multiple profiles that this resource conforms to (or should conform to).

## Validating with the .NET FHIR API

The .NET FHIR API has validation tools:

```csharp
var parser = new FhirJsonParser();

var source = new CachedResolver(new MultiResolver(
        new DirectorySource(@"./profiles"),
        ZipSource.CreateValidationSource())
    );

var ctx = new ValidationSettings()
        {
            ResourceResolver = source,
            GenerateSnapshot = true,
            Trace = false,
            EnableXsdValidation = true,
            ResolveExteralReferences = false
        };

var validator = new Validator(ctx);


try
{
    var parsedResource = parser.Parse(resourceText);
    Console.WriteLine(parsedResource.TypeName);

    OperationOutcome result;
    if (string.IsNullOrEmpty(profile)) 
    {
        result = validator.Validate(parsedResource);
    }
    else
    {
        result = validator.Validate(parsedResource, profile);
    }

    Console.WriteLine(result.ToString());
}
catch (FormatException fe)
{
    Console.WriteLine("Resource could not be parsed");
    Console.WriteLine(fe);
}

```

# High-Level Design

To support the validation needs of our customers, we will need to add a number of capabilities to the server. There are dependencies between the different features, but there is some oportunity to implement them in parallel.

## Validation of referential integrity

Referential integrity is something that customers **may** want to validate and our server **should** be able to do it. It should be optional (see Configuration options below). There are in principle two situations where you might want to validate:

1. On create/update: Make sure that any internal references, e.g. 

    ```json
    {
        "resourceType": "Observation",
        "subject": "Patient/1234",

        // Rest of resourse
    }
    ```

    actually exist in the FHIR server. 

1. On delete: Prevent deletion of a resource that is referenced by other resources.

On SQL server persistence provider, there are some opportunities to take advantage of transactions in both cases. 

## Validate profile on Create/Update

We should handle two cases:

1. When a resource is created or updated we should validate it against **all** profiles specified in `meta.profile` and reject it if any of the validations fail.
1. When a resource is created or updated and **no profiles** are specified in `meta.profile`, we should validate it against any default profile (see configuration below) and reject it if it doesn't conform. 

## Support for `$validate`

The `$validate` operation (https://www.hl7.org/fhir/resource-operation-validate.html) allows a user to check if a resource conforms to a specific profile. 

It can be used in a couple of different ways (that we should support):

1. `POST //fhirserver/Resource/$validate` where the payload is the resource to be validated. 
1. `GET //fhirserver/Resource/1234/$validate` to validate an existing resource.

There are a couple of optional parameters for these:

* `mode`: 
    * `create`: Can this resource be created
    * `update`: Can this resource be updated
    * `delete`: This checks if it would be OK to delete the resource. It should take into consideration if we are validating referential integrity on delete (see configuration below).
* `profile`: The canonical uri for the profile to validate against.

Return `OperationOutcome`.

## Support for `$meta`, `$meta-add` and `$meta-delete`

FHIR specifies two operations for modifying metadata: `$meta-add` and `$meta-delete`. The opration `$meta` simply returns the current metadata. We **should** support these operations to allow users to add profiles to existing resources. We need to consider two situations:

1. If we are adding a profile to an existing resource, we should validate that the resource conforms to the profile and otherwise reject the call.
1. When deleting a profile from metadata, the Resource could fall back to validation agains a default profile for that resource type. That default resource could be more restrictive than the current profile and the validation could fail. In that case, we should not allow removal of the metadata.

Note that we can defer implementation of these operations since there is a workaround by simply updating the resource.

## Configuration options

We need a set of configuration options to allow customers to opt in to referential integrity validation and profile validation. It could look something like:

```json
{
  "FhirServer": {
    "Conformance": {
      "UseStrictConformance": true
    },
    "Validation": {
        "ValidateReferencesOnWrite": true,
        "ValidateReferencesOnDelete": true,
        "ValidateProfiles": true,
        "DefaultProfiles": [
            {
                "ResourceType": "Patient",
                "StructureDefinition": "http://hl7.org/fhir/us/core/StructureDefinition/us-core-patient"
            }
        ]
    }
}
```

## Uploading `StructureDefinition`, `ValueSet`, etc. resources

In order for validation to succeed, the FHIR service must have a way to resolve references (canonical URIs) for profiles, e.g. `http://hl7.org/fhir/us/core/StructureDefinition/us-core-patient` is not a URL that actually points to the StructureDefinition. It should be possible for customers to upload the profiles. Simple solution is to just let customers do:

```
POST //fhirserver/StructureDefinition
```

But we need to make sure that the resolvers pick up these profiles. Another option would be through the portal or the control plane. 

We should also consider adding well known profiles to the server by default, e.g. US Core.

**Note**: StructureDefinitions and ValueSets can be very large. So large in fact that they would not fit in CosmosDB. They should probably be stored somewhere else.

# Test Strategy

We meed to add a number of tests to check that we are validating correctly in all the typical profile use cases, e.g. restriction of cardinality, restricting code systems, etc. We also need explicit testing of referential integrity. 

# Security

The `$validate` operation has some security implications. Information could be leaked if we try to validate a resource and it gets rejected due to referential integrity. Consequently the `$validate` would require the user to have read access in all the compartments relevant to the resource being validated.

# Other

Adding validation capabilities will significantly increase the computational load of the service. When deploying this to PaaS, we should aim to give customers an ability to scale the front-end compute up (at increased cost).

Future work on implementing the [FHIR terminology module](http://www.hl7.org/fhir/terminology-module.html) would need leverage profiles, value sets, etc.